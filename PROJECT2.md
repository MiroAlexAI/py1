# Спецификация программы ChatList

## 1. Назначение программы

ChatList — это Python-приложение, которое позволяет отправлять один и тот же промт (prompt — текстовый запрос, формулирующий задачу для искусственного интеллекта, такого как языковые модели на базе трансформеров) в несколько нейросетей (нейронных сетей, или AI-моделей, таких как GPT от OpenAI, DeepSeek или Groq) и сравнивать их ответы. Пользователь вводит текст запроса, программа отправляет его в выбранные модели через API (Application Programming Interface — интерфейс программирования приложений, позволяющий взаимодействовать с внешними сервисами) и показывает результаты в виде временной таблицы в графическом интерфейсе. Отмеченные пользователем строки сохраняются в постоянную базу данных (БД). 

Улучшение: Для повышения производительности и масштабируемости введена асинхронная обработка запросов (asynchronous programming — подход, где операции выполняются параллельно без блокировки основного потока, используя библиотеку asyncio в Python), что позволяет отправлять промты одновременно в несколько моделей, сокращая время ожидания в 3-5 раз при большом количестве моделей. Это добавляет потенциал для работы с десятками API без значительного роста задержек, делая приложение подходящим для интенсивных экспериментов с AI.

## 2. Стек

- Python 3.11+ (с поддержкой asyncio для асинхронных операций).
- SQLite (реляционная база данных, хранящая данные в файлах без необходимости в сервере, для хранения промтов, моделей, результатов и настроек).
- Библиотека для HTTP-запросов: httpx (современная альтернатива requests, поддерживающая асинхронные запросы для параллельной отправки данных в API).
- GUI: PyQt (библиотека для создания графического интерфейса пользователя, включая таблицы, формы и диалоговые окна).
- Дополнительно: python-dotenv для чтения API-ключей из файла .env (файл конфигурации для хранения чувствительных данных, таких как ключи доступа, в соответствии с принципами безопасности); logging (встроенный модуль Python для записи логов — событий и ошибок для отладки и аудита).

Улучшение: Добавлено логирование и обработка ошибок (error handling — использование конструкций try-except для перехвата исключений, таких как сетевые ошибки, и graceful degradation — продолжение работы при сбоях), что делает приложение более robust (устойчивым) и подходящим для производства. Логи хранятся в файле chatlist.log, позволяя анализировать производительность моделей и отлаживать проблемы без усложнения кода.

## 3. Таблицы базы данных

Программа хранит следующие данные в базе данных SQLite:
- Промты (prompts) — таблица запросов. Поля: id (уникальный идентификатор), date (дата создания), prompt (текст запроса), tags (теги для категоризации).
- Сети (models) — таблица нейросетей. Поля: name (название модели), api_url (URL API), api_id (идентификатор API), is_active (флаг активности).
- Результаты (results) — таблица сохраненных результатов. Поля: id, prompt_id (ссылка на промт), model_name (название модели), response (текст ответа), date (дата получения).
- Настройки (settings) — хранение настроек программы. Поля: key (ключ настройки), value (значение, например, путь к .env или уровень логирования).

API-ключи хранятся не в БД, а в файле .env для безопасности. Имя переменной для ключа указывается в таблице models (например, api_id = "OPENAI_API_KEY").

Улучшение: Добавлена поддержка CRUD-операций (Create, Read, Update, Delete — создание, чтение, обновление, удаление) через GUI для таблицы models, что позволяет пользователям добавлять/редактировать модели без SQL-запросов, повышая usability (удобство использования) и потенциал расширения на новые AI-модели (например, интеграция с будущими сервисами).

## 4. Рабочий процесс

### 4.1 Ввод промта

Пользователь:
- Вводит новый промт, или
- Выбирает один из сохранённых в таблице prompts (с поддержкой поиска и сортировки для удобства навигации по истории).

### 4.2 Отправка запроса

Программа:
- Берёт список активных моделей (models.where(is_active=1)).
- Отправляет промт асинхронно (параллельно) в каждую модель с использованием httpx.AsyncClient для минимизации задержек.
- Обрабатывает ошибки (например, таймауты или неверные ответы API) и логирует их.
- Создаёт временную таблицу результатов в памяти (не в SQLite) для отображения.

### 4.3 Интерфейс результатов

На экране пользователь видит таблицу (QTableView в PyQt), где каждая строка содержит:
- Название модели.
- Текст ответа.
- Чекбокс selected (для выбора сохранения).
- Статус (например, "Success" или "Error: Timeout" для отображения результатов обработки ошибок).

Таблица поддерживает поиск (фильтрацию по ключевым словам) и сортировку по колонкам для удобства анализа.

### 4.4 Сохранение выбранных результатов

Когда пользователь нажимает "Сохранить":
- Все строки с selected = True записываются в таблицу results.
- Временная таблица очищается.

### 4.5 Новый запрос

При вводе нового промта временная таблица:
- Удаляется полностью.
- Создаётся заново после получения новых ответов.

Улучшение: Добавлен GUI для управления моделями — отдельное окно с таблицей и кнопками "Add/Edit/Delete", использующее QSqlTableModel для связи с БД. Это делает процесс конфигурации интуитивным, добавляя потенциал для динамического расширения без редактирования кода.

## 5. Требования к реализации

- Доступ к SQLite должен быть инкапсулирован в модуле db.py (с функциями для CRUD-операций и запросов).
- Логика работы с моделями — в модуле models.py (включая чтение активных моделей и интеграцию с .env).
- Отправка запросов к API — модуль network.py (с асинхронными функциями на базе asyncio и httpx, плюс обработка ошибок).
- Основной интерфейс — main.py (с PyQt для GUI, включая таблицы с поиском/сортировкой и диалоговые окна).

Структура следует принципу Separation of Concerns (разделение обязанностей), обеспечивая модульность и лёгкость тестирования.

## 6. Дополнительные функции

- Во всех таблицах (prompts, models, results) реализован поиск (фильтрация по строке) и сортировка (по колонкам) с использованием QSortFilterProxyModel в PyQt.
- Экспорт выбранных результатов в Markdown (разметка для читаемого текста с таблицами) или JSON (структурированный формат данных) для分享 или интеграции с другими инструментами (реализовано в main.py с использованием tabulate для Markdown и json для JSON).
- Поддержка разных типов моделей (OpenAI, DeepSeek, Groq и т.д.) через конфигурируемые API-URL и параметры.
- Логи запросов (включая время выполнения, ошибки и статусы) для анализа и отладки.

Улучшение: Эти функции добавлены как базовые, а не опциональные, но с минимальной сложностью (каждая — 30-100 строк кода), чтобы проект обрёл потенциал для исследований AI: от быстрого сравнения до накопления и экспорта данных для отчётов. Аргументация — они повышают scalability (масштабируемость) и user-friendliness без перегрузки, позволяя эволюционировать от простого инструмента к полноценной платформе.